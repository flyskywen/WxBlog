<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>vue组件的生命周期钩子</title>
</head>

<body>
    <div id="app">
        <h1>一个vue组件从创建到销毁整个生命周期过程中一些时间节点回调的方法</h1>
        <local-tag></local-tag>
    </div>
</body>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<script>
    let localTag = {
        template: `
        <div>
            <input type="text" v-model="msg">
            <p>
            {{ msg }}
            </p>
        </div>
        `,
        data() {
            return {
                msg: '局部组件',
                x: 'x',
                y: 'y'
            }
        },
        methods: {
            btnClick() {
                console.log(this.msg)
            },
            zzz() {}
        },
        beforeCreate() {
            //vue实例刚刚创建，什么都没干
            console.log('组件开始创建，数据和事件都为创建');
            console.log(this.msg);
            console.log(this.btnClick);
            console.log(this.$data);
            console.log(this.$el)
        },
        pppp: [1, 2, 3],
        created() {
            // 主dom元素还没有加载
            // 创建了数据、计算属性、方法、监听 统统创建，但是挂载元素还没有创建。
            // 也就是虚拟dom已经准备好了，而真实dom对于vue来说现在还不可见，也没有对真实dom进行替换。
            // 可以在这里获取服务端的数据
            console.log('组件已经创建完毕，数据与事件都准备就绪');
            console.log(this.msg); // 可以获取
            console.log(this.btnClick); // 可以获取
            console.log(this.$data); //  可以获取
            console.log(this.$el); // undifined
            console.log(this.$options.methods); // 获取到methods
            console.log(this.$options.pppp); // 一般用于获取vue一些没有提供的便捷访问的属性（比如自定义）。
        },
        mounted() {
            // 组件已经加载完毕
            console.log('组件已经加载完毕');
            console.log(this.$el) // 比created阶段多了el挂在元素
        },
        updated: function () {
            // 每次 data的 数据更新完成的时候都会触发这里,也就意味着会频繁触发
            console.log('属性更新完成', this.msg);
        }
    };

    new Vue({
        el: '#app',
        components: {
            localTag, // 从这里触发子组件的生命周期
        }
    })
</script>

</html>